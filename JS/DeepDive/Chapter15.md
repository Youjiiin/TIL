# 15장 let, const 키워드와 블록 레벨 스코프

## 15.1 var 키워드로 선언한 변수의 문제점
- 변수 중복 선언 허용
```
var x = 1;
var x = 100;

console.log(x); // 100
```
: 이와 같이 코드를 작성해도 에러가 발생하지 않는다. 이는 의도치 않은 값을 할당할 수 있는 위험이 있다.

- 함수 레벨 스코프
```
var i = 10;

for (let i = 0; i < 5; i++) {
    console.log(i); // 0 1 2 3 4
}

console.log(i); // 5
```
: 함수 외부에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 된다. 함수 레벨 스코프는 전역 변수를 남발할 가능성을 높인다.

- 변수 호이스팅
```
console.log(foo); // undefined

foo = 123;

console.log(foo); // 123
```
: var 키워드로 변수를 선언하면 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작한다. 그렇기에 변수 선언 이전에 호출하면 `undefined`를 반환한다. (let, const는 참조에러 발생)

## 15.2 let 키워드
- 변수 중복 선언 금지
```
let bar = 123;

let bar = 456; // SyntaxError
```

- 블록 레벨 스코프
```
let foo = 1;

{
    let foo = 2;
    let bar = 3;
}

console.log(foo); // 1
console.log(bar); // ReferenceError
```
: let 키워드로 선언된 변수는 블록 레벨 스코프를 따른다.

- 변수 호이스팅
```
console.log(x); // ReferenceError
let foo;
```
: 변수 호이스팅이 발생하지 않는 것 처럼 보인다. var 키워드로 선언한 변수는 런타임 이전에 선언 단계와 초기화 단계가 진행되는 반면, let 키워드로 선언한 변수는 '선언 단계'와 '초기화 단계'가 분리되어 진행된다. 그렇기에 초기화 단계가 실행되기 이전에 변수에 접근하면 참조에러가 발생한다. 

- 전역 객체와 let 
```
let x = 1;

console.log(window.x); // undefined
console.log(x); // 1
```
: let 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니기에 window.x와 같이 접근할 수 없다.

## 15.3 const 키워드 
- const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다. 
- 재할당 금지 : const 키워드로 선언한 변수는 재할당이 금지된 '상수'이다. 상수의 이름은 보통 대문자로 선언해 상수임을 나타낸다. (ex. TAX_RATE)
- const 키워드로 선언된 변수에 객체를 할당한 경우엔 값을 변경할 수 있다. 변경 불가능한 값인 원시 값은 재할당 없이 변경할 수 있는 방법이 없지만, 변경 가능한 값인 객체는 재할당 없이도 직접 변경이 가능하기 때문이다. -> const 키워드는 재할당을 금지할 뿐 "불변"을 의미하지는 않는다. 

## var vs let vs const
- ES6를 사용한다면 `var`키워드는 사용하지 않는다.
- 재할당이 필요한 경우에 한정해 `let`키워드를 사용한다. 이때, 변수의 스코프는 최대한 좁게 만든다.
- 변경이 발생하지 않고 읽기 전용으로 사용하는(재할당이 필요 없는) 원시 값과 객체에는 `const` 키워드를 사용한다. const 키워드는 재할당을 금지하므로 var, let 키워드보다 안전하다.